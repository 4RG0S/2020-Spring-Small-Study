#소소하게 4회차

https://blog.naver.com/ygo65312/221925582085

오늘은 운영체제 및 실습 6주차 과제 중 실습 1번부터 5번까지를 수행하였다.

​

실습 1: pipe & redirection


input.c 코드


output.c 코드


input.c 컴파일 하여 얻은 실행파일 실행 결과


output.c 컴파일 하여 얻은 실행파일 실행 결과


파이프를 사용하여 input 실행결과를 output 실행파일에게 전달한 결과


redirection을 이용하여 input 출력을 msg.txt로 하고 다시 이를 입력으로 output 실행한 결과

실습 2: pipe() 실습


pipeTest.c 코드


컴파일하여 얻은 실행파일 실행 결과

pipe 이용하여 부모와 자식 프로세스가 각 위치에 쓰고 서로가 쓴 것들을 다시 읽어온 모습이다.

​

실습 3: FIFO 실습

코드는 자료에 주어진 코드 그대로를 사용. 실행결과는 다음과 같다.


send 실행에서 수행한 것


recv에서 send 실행에 따라 나온 결과

FIFO : Named PIPE. 프로세스 두 개 이상의 자료를 교환하기 위해 커널 버퍼를 임시 저장 공간으로 사용함.

입력에 따라 실시간으로 send에서 recv로 데이터가 송신되고 있음을 확인할 수 있었다.

​

실습 4-1: Mutual Exclusion

mutex, semaphore 사용 전 다중 스레드 코드 작동 결과는 다음과 같다.


한꺼번에 다섯 스레드가 전역변수 key에 접근함

반복문을 이용하여 하나씩만 순서대로 접근가능하도록 고친 후의 실행 결과는 다음과 같다.


한 스레드씩 순서대로 key에 접근하여 값을 수정함

실습 4-2: Mutual Exclusion

위의 문제에서 여러 스레드가 한 번에 임계영역에 접근하는 것을 mutex를 이용하여 해결하였다.

스레드 생성정 mutex를 init하고 각 스레드들은 mutex가 unlock일 때까지 대기하며 자신의 순서를 기다린다.


실행 결과

실습 5-1: Semaphore

임계영역 접근을 최대 4개의 스레드가 할 수 있게 반복문을 이용하여 구현한 결과이다.


실습 5-2: Semaphore

실습 5-1와 같은 문제를 semaphore를 이용하여 해결하였다. sem_wait()은 카운트 값을 1 감소,

sem_post()는 카운트 값을 1 증가 시키면서 최대 4개의 스레드들이 임계영역에 접근할 수 있도록 설정한다. 실행 결과는 다음과 같다.


